import { describe, test, expect, beforeEach, jest } from "@jest/globals";
import { InterWindowMessaging } from "../../InterWindowMessaging.js";

describe("InterWindowMessaging Compatibility (Task 4.1)", () => {
	let mockTargetWindow;
	let functionSet;

	beforeEach(() => {
		delete global.window.location;
		global.window.location = new URL("http://localhost/");

		mockTargetWindow = {
			postMessage: jest.fn(),
			location: { origin: "http://localhost" }
		};
		functionSet = {
			test: jest.fn().mockResolvedValue("ok")
		};
	});

	test("should support legacy constructor with boolean responseReady", async () => {
		// New InterWindowMessaging(functionSet, targetWindow, true)
		const iwm = new InterWindowMessaging(functionSet, mockTargetWindow, true);
		
		await new Promise(resolve => setTimeout(resolve, 50));

		// Should send 'ready: true' message immediately
		expect(mockTargetWindow.postMessage).toHaveBeenCalled();
		const call = mockTargetWindow.postMessage.mock.calls.find(c => JSON.parse(c[0]).ready === true);
		expect(call).toBeDefined();
	});

	test("should support options object in the 5th argument", async () => {
		// new InterWindowMessaging(funcSet, target, responseReady, allowedOrigins, options)
		const options = { timeout: 1000, handshake: true, submitReady: true };
		const iwm = new InterWindowMessaging(functionSet, mockTargetWindow, false, [], options);
		
		await new Promise(resolve => setTimeout(resolve, 50));

		// If options.submitReady is true, it should still send ready: true
		expect(mockTargetWindow.postMessage).toHaveBeenCalled();
		const call = mockTargetWindow.postMessage.mock.calls.find(c => JSON.parse(c[0]).ready === true);
		expect(call).toBeDefined();
	});

	test("should maintain callRemoteFunc signature and behavior", async () => {
		const iwm = new InterWindowMessaging(functionSet, mockTargetWindow, true);
		
		await new Promise(resolve => setTimeout(resolve, 50));

		// Mock a response for the callRemoteFunc
		// We need to capture the ID generated by iwm
		let capturedId;
		mockTargetWindow.postMessage.mockImplementation((json) => {
			const msg = JSON.parse(json);
			if (msg.command === "remoteFunc") {
				capturedId = msg.id;
			}
		});

		const promise = iwm.callRemoteFunc("remoteFunc", ["arg1"]);
		
		await new Promise(resolve => setTimeout(resolve, 50));

		// Simulate response
		const responseEvent = {
			origin: "http://localhost",
			source: mockTargetWindow,
			data: JSON.stringify({
				id: capturedId,
				response: "remoteFunc",
				content: "remoteResult"
			})
		};
		window.dispatchEvent(new MessageEvent("message", responseEvent));

		const result = await promise;
		expect(result).toBe("remoteResult");
	});

	test("should remain silent for unhandled commands in multi-instance environment", async () => {
		// インスタンス A: 'cmdA' のみ担当
		const functionSetA = { cmdA: jest.fn().mockResolvedValue("resultA") };
		const iwmA = new InterWindowMessaging(functionSetA, mockTargetWindow, false);

		// インスタンス B: 'cmdB' のみ担当
		const functionSetB = { cmdB: jest.fn().mockResolvedValue("resultB") };
		const iwmB = new InterWindowMessaging(functionSetB, mockTargetWindow, false);

		mockTargetWindow.postMessage.mockClear();

		// 'cmdB' を送信
		const msgId = "test-id-123";
		const messageEvent = {
			origin: "http://localhost",
			source: mockTargetWindow,
			data: JSON.stringify({
				id: msgId,
				command: "cmdB",
				parameter: []
			})
		};
		window.dispatchEvent(new MessageEvent("message", messageEvent));

		// 非同期処理を待機
		await new Promise(resolve => setTimeout(resolve, 50));

		// 検証:
		// 1. インスタンス A は cmdB を知らないので、何も返信していないはず
		// 2. インスタンス B は cmdB を知っているので、1回だけ正しく返信しているはず
		
		// 以前のバグでは、インスタンス A が 'error' レスポンスを返してしまい、合計2回の呼び出しが発生していた
		expect(mockTargetWindow.postMessage).toHaveBeenCalledTimes(1);
		
		const response = JSON.parse(mockTargetWindow.postMessage.mock.calls[0][0]);
		expect(response.response).toBe("cmdB");
		expect(response.content).toBe("resultB");
		expect(response.id).toBe(msgId);
	});
});
