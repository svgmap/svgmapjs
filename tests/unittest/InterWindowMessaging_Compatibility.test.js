import { describe, test, expect, beforeEach, jest } from "@jest/globals";
import { InterWindowMessaging } from "../../InterWindowMessaging.js";

describe("InterWindowMessaging Compatibility (Task 4.1)", () => {
	let mockTargetWindow;
	let functionSet;

	beforeEach(() => {
		delete global.window.location;
		global.window.location = new URL("http://localhost/");

		mockTargetWindow = {
			postMessage: jest.fn(),
			location: { origin: "http://localhost" }
		};
		functionSet = {
			test: jest.fn().mockResolvedValue("ok")
		};
	});

	test("should support legacy constructor with boolean responseReady", async () => {
		// New InterWindowMessaging(functionSet, targetWindow, true)
		const iwm = new InterWindowMessaging(functionSet, mockTargetWindow, true);
		
		await new Promise(resolve => setTimeout(resolve, 50));

		// Should send 'ready: true' message immediately
		expect(mockTargetWindow.postMessage).toHaveBeenCalled();
		const call = mockTargetWindow.postMessage.mock.calls.find(c => JSON.parse(c[0]).ready === true);
		expect(call).toBeDefined();
	});

	test("should support options object in the 5th argument", async () => {
		// new InterWindowMessaging(funcSet, target, responseReady, allowedOrigins, options)
		const options = { timeout: 1000, handshake: true, submitReady: true };
		const iwm = new InterWindowMessaging(functionSet, mockTargetWindow, false, [], options);
		
		await new Promise(resolve => setTimeout(resolve, 50));

		// If options.submitReady is true, it should still send ready: true
		expect(mockTargetWindow.postMessage).toHaveBeenCalled();
		const call = mockTargetWindow.postMessage.mock.calls.find(c => JSON.parse(c[0]).ready === true);
		expect(call).toBeDefined();
	});

	test("should maintain callRemoteFunc signature and behavior", async () => {
		const iwm = new InterWindowMessaging(functionSet, mockTargetWindow, true);
		
		await new Promise(resolve => setTimeout(resolve, 50));

		// Mock a response for the callRemoteFunc
		// We need to capture the ID generated by iwm
		let capturedId;
		mockTargetWindow.postMessage.mockImplementation((json) => {
			const msg = JSON.parse(json);
			if (msg.command === "remoteFunc") {
				capturedId = msg.id;
			}
		});

		const promise = iwm.callRemoteFunc("remoteFunc", ["arg1"]);
		
		await new Promise(resolve => setTimeout(resolve, 50));

		// Simulate response
		const responseEvent = {
			origin: "http://localhost",
			source: mockTargetWindow,
			data: JSON.stringify({
				id: capturedId,
				response: "remoteFunc",
				content: "remoteResult"
			})
		};
		window.dispatchEvent(new MessageEvent("message", responseEvent));

		const result = await promise;
		expect(result).toBe("remoteResult");
	});

	test("should maintain postMessageTo signature", () => {
		const iwm = new InterWindowMessaging(functionSet, mockTargetWindow, true);
		const otherWindow = {
			postMessage: jest.fn(),
			location: { origin: "http://other.com" }
		};
		
		iwm.postMessageTo(otherWindow, { data: "test" });
		
		expect(otherWindow.postMessage).toHaveBeenCalled();
		const sentData = JSON.parse(otherWindow.postMessage.mock.calls[0][0]);
		expect(sentData.data).toBe("test");
	});
});
